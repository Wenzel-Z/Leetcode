import static org.junit.jupiter.api.Assertions.assertEquals;

import org.junit.jupiter.api.Test;

public class remove_palindromic_subsequences {
    public int removePalindromeSub(String s) {
        if (s.isEmpty()) {
            return 0;
        }
        int left = 0;
        int right = s.length()-1;
        while (left < right) {
            if (s.charAt(left) != s.charAt(right)) {
                return 2;
            }
            left++;
            right--;
        }
        return 1;
    }

    public int removePalindromeSub2(String s) {
        if (s.isEmpty()) {
            return 0;
        }
        String reverse = new StringBuilder(s).reverse().toString();
        if (reverse.equals(s)) {
            return 1;
        }
        return 2;
    }

    @Test
    public void testPalindrome() {
        assertEquals(1, removePalindromeSub("ababa"));
        assertEquals(2, removePalindromeSub("abb"));
        assertEquals(2, removePalindromeSub("baabb"));
    }
}

/*
https://leetcode.com/problems/remove-palindromic-subsequences/
Explanation
A string is a subsequence of a given string if it is generated by deleting some characters of a given string without changing its order. 
Note that a subsequence does not necessarily need to be contiguous

Not a trick problem. There are only 2 outcomes, if it is a palindrome return 1, else return 2. Return 0 is just an optional.
So in the solution you can do two things

1. Reverse a string and then compare it with the original string, if they are equal then it is a palindrome
2. Use two pointers to find if the string is palindrome

Time: O(n)
Space: O(n) for reverse string, O(1) for two pointers
*/